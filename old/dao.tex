%\documentclass[times, twocolumn]{article}
%\usepackage{latex8}
%\usepackage{times}
%\documentclass[times, 10pt,twocolumn]{article}
%\usepackage{latex8}
%\usepackage{times}
%\documentclass{article}
%\documentclass{lmcs}
%\documentclass[envcountsame,envcountsect]{llncs}
%\documentclass[runningheads,a4paper]{llncs}
%\documentclass[3p]{elsarticle}
\documentclass[10pt]{llncs}
%\usepackage{times}
%\documentclass{fsttcs-ps}
%\documentclass{fsttcs-pdf}
%\documentclass{amsart}

\usepackage{amssymb,amsmath,pifont,footnote}
\usepackage{latexsym,pdfpages}
\usepackage{array,verbatim}
\usepackage{algorithmic,algorithm}
\usepackage{cite}
%\usepackage{widetext}
\usepackage{fullpage}
% \usepackage{a4wide}
% \usepackage{times}
%\newcommand{\pfbox}{\quad\hspace*{\fill}$\Box$}

%\usepackage{algpseudocode}% http://ctan.org/pkg/algorithmicx
%\renewcommand{\algorithmiccomment}[1]{\hfill\eqparbox{COMMENT}{\# #1}}
\newtheorem{thm}{Theorem} %Added
\newtheorem{notat}[thm]{Notations}
%\newtheorem{lem}[thm]{Lemma}
\newtheorem{lem}{Lemma}
\newtheorem{WorkAround}{Lemma}
%\newtheorem{prop}[thm]{Proposition}
\newtheorem{prop}{Proposition}
%\newtheorem{rem}[thm]{Remark}
\newtheorem{rem}{Remark}
\newtheorem{prob}{Problem}
\newtheorem{fact}{Fact}

%\newtheorem{cor}[thm]{Corollary}
\newtheorem{cor}{Corollary}
\newtheorem{Obs}{Observation}
%\newenvironment{prop}{\theoremlike{Proposition}}{\par\medskip}
%\theoremlike{prop}{<caption>}[<within>]
%{\bfseries}{\itshape}
%\newtheorem{defn}[thm]{Definition}
\newtheorem{defn}{Definition}
\newtheorem{examp}{Example}

%

%\newcommand{\pfbox}{\quad\hspace*{\fill}$\Box$}
%\newcommand{\pfbox}{\quad\hspace*{\fill}$\Box$}

\newcommand{\pfbox}{}


%\newenvironment{proof}{\noindent {\bf Proof}~}{\pfbox\bigskip}



\newtheorem{dfn}[thm]{Definition}
\newcommand{\tuple}[1]{\left(#1\right)}
\newcommand{\bliml}{\mathit{Base}_{\underrightarrow{\lim }} }
\newcommand{\blimr}{\mathit{Base}_{\underleftarrow{\lim }} }

\newcommand{\SC}{\mathcal{SFOT_{\cA}}}
\newcommand{\ub}{\mathit{ub}}

\newcommand{\sft}{\mathcal{SFOT}_{n}}
\newcommand{\cA}{\mathcal{A}}
\newcommand{\cC}{\mathcal{C}}
\newcommand{\cL}{\mathcal{L}}
\newcommand{\cI}{\mathcal{I}}
\newcommand{\wi}{\mathit{Win_{I}}}
\newcommand{\McN}{\mathit{McNGame}}
\newcommand{\cB}{\mathcal{B}}
\newcommand{\cond}{FOT }
\newcommand{\ra}{\rightarrow}
\newcommand{\lar}{\leftarrow}
\newcommand{\Ps}[1]{\mathbb{P}( #1 )}
\newcommand{\gt}{\mbox{game-type}}
\newcommand{\code}{\mbox{Code}}
\newcommand{\trun}{\mbox{trun}}
\newcommand{\gcode}{\mbox{gcode}}
\newcommand{\Play}{\mbox{Play}}
\newcommand{\nat}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\mcT}{\mathcal{T}}
\newcommand{\om}{\omega}

% Yaronv new commands
\newcommand{\PlusMinus}{+-}
\newcommand{\Set}[1]{\{ #1 \}}
\newcommand{\Range}[2]{#1 ,\dots, #2}
\newcommand{\RangeSet}[2]{\Set{ \Range{#1}{#2}}}
\newcommand{\EC}{\mathit{EC}}
\newcommand{\ER}{\mathit{ER}}
\newcommand{\Interp}{\mathit{Interp}}
\newcommand{\PSR}[1]{\ensuremath{\mathit{PSR}(#1)}}
\newcommand{\DE}[1]{\textrm{DE}_{#1}}
\newcommand{\UDE}[1]{\textrm{UDE}_{#1}}
\newcommand{\DEfin}{\ensuremath{ \textrm{{DE}}_{\mathit{fin}}   }    }
\newcommand{\UDEfin}{\ensuremath{ \textrm{{UDE}}_{\mathit{fin}}   }    }

\newcommand{\BeginMultiCycle}{\overrightarrow{\mathfrak{m}}}
\newcommand{\EndMultiCycle}{\overleftarrow{\mathfrak{m}}}
\newcommand{\BeginCycle}{\overrightarrow{\mathfrak{c}}}
\newcommand{\EndCycle}{\overleftarrow{\mathfrak{c}}}

\newcommand{\highz}{\ensuremath{z}}
\newcommand{\E}[1]{\textrm{E}_{#1}}
\newcommand{\Efin}{\ensuremath{ \textrm{{E}}_{\mathit{fin}}   }    }
\newcommand{\MSO}{\textrm{MSO}}
\newcommand{\Couple}[2]{\ensuremath{\binom{#2}{#1}}}
\newcommand{\SigLetter}[2]{\ensuremath{\sigma_{#1}(#2)}}
\newcommand{\SigLetterOne}[1]{\ensuremath{\SigLetter{1}{#1}}}
\newcommand{\SigLetterTwo}[1]{\SigLetter{2}{#1}}
\newcommand{\SigTuple}[1]{\Couple{\SigLetterOne{#1}}{ \SigLetterTwo{#1} } }
\newcommand{\sigTuple}{\Couple{\sigma_1}{ \sigma_2 } }
\newcommand{\SigmaMult}{\ensuremath{\Sigma_1 \times \Sigma_2}}
\newcommand{\SigmaMultOmega}{\ensuremath{(\SigmaMult)^\omega}}
\newcommand{\SigmaEps}{\ensuremath{\Sigma_1 \cup \singelton{\highz}}}
\newcommand{\SigmaEpsMult}{\ensuremath{(\SigmaEps) \times \Sigma_2}}
\newcommand{\SigmaEpsMultOmega}{\ensuremath{(\SigmaEpsMult)^\omega}}
\newcommand{\GameGraph}[1]{\langle #1 \rangle}
\newcommand{\Tuple}[1]{\langle #1 \rangle}
\newcommand{\WtFunc}{\mathit{wt}}
\newcommand{\QDeadEnd}{ \ensuremath{ q_{\mbox{dead-end}} } }
\newcommand{\MPSupGeq}[1]{\ensuremath{\textrm{MeanPayoffSup}^{\geq}(#1)}}
\newcommand{\MPSupGt}[1]{\ensuremath{\textrm{MeanPayoffSup}^{>}(#1)}}
\newcommand{\MPSupGeneric}[1]{\ensuremath{\textrm{MeanPayoffSup}^{\sim}(#1)}}
\newcommand{\MPInfGeneric}[1]{\ensuremath{\textrm{MeanPayoffInf}^{\sim}(#1)}}
\newcommand{\MPSupBoth}[1]{\ensuremath{\textrm{MeanPayoffSup}^{\geq, >}(#1)}}
\newcommand{\MPInfBoth}[1]{\ensuremath{\textrm{MeanPayoffInf}^{\geq, >}(#1)}}
\newcommand{\MPSupGenericIndexed}[2]{\ensuremath{\textrm{MeanPayoffSup}^{\sim_{#2}}(#1)}}
\newcommand{\MPInfGenericIndexed}[2]{\ensuremath{\textrm{MeanPayoffInf}^{\sim_{#2}}(#1)}}
\newcommand{\MPSupLeq}[1]{\ensuremath{\textrm{MeanPayoffSup}^{\leq}(#1)}}
\newcommand{\MPInfGeq}[1]{\ensuremath{\textrm{MeanPayoffInf}^{\geq}(#1)}}
\newcommand{\MPInfGt}[1]{\ensuremath{\textrm{MeanPayoffInf}^{>}(#1)}}
\newcommand{\MPInfLeq}[1]{\ensuremath{\textrm{MeanPayoffInf}^{\leq}(#1)}}
\newcommand{\MPInfLt}[1]{\ensuremath{\textrm{MeanPayoffInf}^{<}(#1)}}
\newcommand{\EL}[1]{\ensuremath{\mathit{EL}(#1)}}
\newcommand{\MPSup}{\ensuremath{ \overline{\mathit{MP}}}}
\newcommand{\MPInf}{\ensuremath{ \underline{\mathit{MP}}}}
\newcommand{\OrMP}{\ensuremath{O^{\textrm{MP}}}}
\newcommand{\AttrOne}[1]{\ensuremath{Attr_1(#1)}}
\newcommand{\AttrTwo}[1]{\ensuremath{Attr_2(#1)}}
\newcommand{\AttrOneG}[2]{\ensuremath{Attr_1^{#1}(#2)}}
\newcommand{\AttrTwoG}[2]{\ensuremath{Attr_2^{#1}(#2)}}
\newcommand{\Attri}[1]{\ensuremath{Attr_i(#1)}}
\newcommand{\Automat}[1]{\ensuremath{\mathcal{#1}}}

\newcommand{\ConjMPSupGeq}[1]{\ensuremath{\bigwedge\MPSupGeq{#1}}}
\newcommand{\ConjMPSupGenericIndexed}[2]{\ensuremath{\bigwedge\MPSupGenericIndexed{#1}{#2}}}
\newcommand{\ConjMPSupGt}[1]{\ensuremath{\bigwedge\MPSupGt{#1}}}
\newcommand{\ConjMPInfGeq}[1]{\ensuremath{\bigwedge\MPInfGeq{#1}}}
\newcommand{\ConjMPInfGt}[1]{\ensuremath{\bigwedge\MPInfGt{#1}}}
\newcommand{\ConjMPInfGenericIndexed}[2]{\ensuremath{\bigwedge\MPInfGenericIndexed{#1}{#2}}}
\newcommand{\ConjMPInfSupGeq}[2]{\ensuremath{\bigwedge\textrm{MeanPayoffInf}^{\geq}_{#2}(#1)\wedge\bigwedge\textrm{MeanPayoffSup}^{\geq}_{#2 ^c}(#1)}} \newcommand{\ConjMPInfSupGt}[2]{\ensuremath{\bigwedge\textrm{MeanPayoffInf}^{>}_{#2}(#1)\wedge\bigwedge\textrm{MeanPayoffSup}^{>}_{#2 ^c}(#1)}}

\newcommand{\ConjDisjMPSupGeq}[1]{\ensuremath{\bigwedge\bigvee\MPSupGeq{#1}}}
\newcommand{\DisjConjMPInfGeq}[1]{\ensuremath{\bigvee\bigwedge\MPInfGeq{#1}}}
\newcommand{\ConjDisjMPSupGt}[1]{\ensuremath{\bigwedge\bigvee\MPSupGt{#1}}}
\newcommand{\DisjConjMPInfGt}[1]{\ensuremath{\bigvee\bigwedge\MPInfGt{#1}}}
\newcommand{\ConjDisjMPSupBoth}[1]{\ensuremath{\bigwedge\bigvee\MPSupBoth{#1}}}
\newcommand{\DisjConjMPInfBoth}[1]{\ensuremath{\bigvee\bigwedge\MPInfBoth{#1}}}

\newcommand{\HQ}{\mathit{H10(\Q)}}

\newcommand{\Heading}[1]{\smallskip\noindent{\bf{#1}}}

%\newcommand{\Heading}[1]{\vspace{-0.25cm}\paragraph{\bf{#1}}}
\newcommand{\BeginProof}{\vspace{-0.25cm}\begin{proof}}
\newcommand{\PreSection}{\vspace{-0.5cm}}
\newcommand{\PostSection}{\vspace{-0.0cm}}


%\newcommand{\Heading}[1]{\noindent\textbf{#1}}
\newcommand{\PreItemize}{\vspace{-0.1cm}}
\newcommand{\PostItemize}{\vspace{-0.1cm}}

\newcommand{\ProofOutline}[1]{\paragraph{\bf{A proof outline for {#1}}}}
%\newcommand(\PreSection}{\vspace{-0.25cm}}
%\newcommand(\EndSection}{\vspace{-0.25cm}}

\newcommand{\Comment}[1]{}
\newcommand{\Appendix}[1]{}

\newcommand{\MAX}{\max}
\newcommand{\MIN}{\min}
\newcommand{\SUM}{\operatorname{sum}}
\newcommand{\OP}{\operatorname{op}}
\newcommand{\Avg}{\mathit{Avg}}
\newcommand{\LimAvg}{\mathit{LimAvg}}
\newcommand{\LimInfAvg}{\mathit{LimInfAvg}}
\newcommand{\LimSupAvg}{\mathit{LimSupAvg}}
\newcommand{\LimSupAvgAutomat}[1]{\overline{#1}}
\newcommand{\LimInfAvgAutomat}[1]{\underline{#1}}


\newcommand{\NoMax}{\mathit{NoMax}}

\newcommand{\InfAvgLan}[2]{\underline{#1}^{\geq #2}}
\newcommand{\SupAvgLan}[2]{\overline{#1}^{\geq #2}}

\newcommand{\MultiCycle}[1]{\mathbf{#1}}
\newcommand{\VEC}[1]{\ensuremath{\overline{#1}}}

\newcommand{\ProofOfRem}[1]{of Remark \ref{#1}}
\newcommand{\ProofOfThm}[1]{of Theorem \ref{#1}}
\newcommand{\ProofOfLem}[1]{of Lemma \ref{#1}}
\newcommand{\ProofOfProp}[1]{of Proposition \ref{#1}}
\newcommand{\ProofOfCor}[1]{of Corollary \ref{#1}}
\newcommand{\ProofOfObs}[1]{of Observation \ref{#1}}


\def\vp{\varphi}
\def\mG{\mathcal{G}}
\def\rar{\rightarrow}
\def\power{\mathcal{P}}
\def\s{\subseteq}
\def\All{\forall}
\def\we{\wedge}
\def\dep{\mathit{qd}}
\newcommand{\MLO}{\mbox{MLO}}
\newcommand{\FOMLO}{\mbox{FOMLO}}
\def\mL{\mathcal{L}}
\def\mM{\mathcal{M}}
\def\mR{\mathcal{R}}
\def\mI{\mathcal{I}}
\def\mJ{\mathcal{J}}
\def\mN{\mathcal{N}}
\def\MTh{\mathit{MTh}}
\def\HF{\mathit{type}}
\def\Th{\mathit{Th}}
\def\mD{\mathcal{D}}
\def\Form{\mathfrak{Form}}
\def\fS{\mathfrak{S}}
\def\fH{\mathfrak{H}}
\def\nek{\ldots}
\newcommand{\qd}[1]{\mathop{\rm qd}(#1)}
\def\strucmult{\otimes}
\def\typemult{\otimes}
\def\la{\lambda}
\def\close{\mathit{Closed}}
\def\win{\mathit{Win}}
\def\Realize{\mbox{Realize}}
\def\Dsynth{\mbox{Dsynth}}
\def\Fsynth{\mbox{Fsynth}}






\def\st{\mathit{st}}
\def\type{\mathit{type}}
\def\ttype{\mathit{ptype}}
\def\sgame{\mathit{Game}}
\def\res{\mathit{res}}
\def\win{\mathit{win}}
\def\Win{\mathit{Win}}
\def\Dwin{\mathit{Dwin}}
\def\Fswin{\mathit{Fswin}}
\def\Mult{\mathit{Mult}}
\newcommand{\G}[2]{R(#1,#2)}
\def\owin{\mbox{Or-win}}
\def\scaus{\mbox{I-Player-strategy}}
\def\caus{\mbox{II-Player-strategy}}
\def\upd{\mbox{next}}
\def\upl{\Delta}
\def\out{\mbox{out}}
\DeclareMathOperator{\rank}{rank}
\DeclareMathOperator{\weight}{weight}
\DeclareMathOperator{\col}{col}
\def\Dl{D^-}
\def\Dr{D^+}
\def\type{\mathit{type}}
\def\rest{\lfloor}
\def\dom{\partial}
\DeclareMathOperator{\Llim}{llim} \DeclareMathOperator{\Rlim}{rlim}
\def\aaut{\mathfrak{ A}}
\def\baut{\mathfrak{ B}}
\def\abasis{B}
\newcommand{\powerset}[1]{\mathcal{P}({#1})}
\newcommand{\arun}{\rho}
\newcommand{\AL}{{\rm always}}
\def\next{\mathit{next}}
\def\word{\mathit{s}}

\newcommand{\until}{{\sf Until}}
\newcommand{\since}{{\sf Since}}
\newcommand{\ltl}{{\rm LTL}}
\newcommand {\pspace} {\textsc{pspace}}
\newcommand{\mainlogic}{\TL(\until,\since)}

\newcommand{\Nat}{\ensuremath{\mathbb{N}}}
\newcommand{\Rat}{\ensuremath{\mathbb{Q}}}
\newcommand{\Rea}{\ensuremath{\mathbb{R}}}
\newcommand {\exptime} {\textsc{exptime}}
\def\Unbound{\mathit{Unbound}}
\def\Dense{\mathit{Dense}}
\def\blim{\mathit{base}-\lim}
\def\class{\mathcal{ C}}
\def\fF{\mathfrak{F}}
\def\clos{\mathit{Cl}}
\def\shuf{\mathit{shuffle}}
\def\fset{finite-set }
%\newcommand{\}{\mathit{Hin}}
\newcommand{\hin}{\mathit{Hin}}
\newcommand{\Flag}{\mbox{Updated}}
\newcommand{\false}{\mbox{False}}
\newcommand{\true}{\mbox{True}}
\newcommand{\TL}{\mathit{TL}}
\def\Left{\mathit{Left}}
\def\Right{\mathit{Right }}
\def\ovarphi{{\overline\varphi}}
\def\Neg{\mathit{Neg}}
\def\Id{\mathit{Id}}
\def\Conj{\mathit{Conj}}
\def\Disj{\mathit{Disj}}
\def\tr{\mathit{Tr}}
\def\diamonds{\overleftarrow{\diamondsuit}}
\newcommand{\LE}{\mbox{\it{Q2MLO}$_\exists$}}
\def\Lreg{\class_{reg}}
\def\lab{\mathit{lab}}
\def\Rreg{\mR_{reg}}




\def\One{\mathit{One}}
\newcommand{\CMPSup}{\ensuremath{\bigwedge \textrm{MeanPayoffSup} }}
\newcommand{\CMPInf}{\ensuremath{\bigwedge \textrm{MeanPayoffInf} }}
\newcommand{\DMPSup}{\ensuremath{\bigvee \textrm{MeanPayoffSup} }}
%\newcommand{\SPAN}{\operatorname{SPAN}}
%\newcommand{\SPANge}{\operatorname{SPAN}^{\geq}}
%\newcommand{\SMPO}{\operatorname{SMPO}}

\newcommand{\DMPInf}{\ensuremath{\bigvee \textrm{MeanPayoffInf} }}

\newcommand{\MinExpVal}[2]{\ensuremath{\min_{#2} {#1}}}
\newcommand{\Floor}[2]{\ensuremath{\lfloor{#1}\rfloor_\frac{1}{#2}}}

\newcommand{\Char}{\operatorname{characterization}}
\newcommand{\EChar}{\operatorname{ECP}}
\newcommand{\SCC}{\operatorname{SCC}}
\newcommand{\Cycle}{\operatorname{Cycle}}
\newcommand{\CONV}{\mathit{CONVEX}}
\newcommand{\UCSPAN}{\mathit{UCSPAN}}
\newcommand{\DCSPAN}{\mathit{DCSPAN}}
\newcommand{\RelRatSPAN}{\mathit{relRatSPAN}}
\newcommand{\RelSPAN}{\mathit{relSPAN}}
\newcommand{\UC}{\mathit{UC}}
\newcommand{\DC}{\mathit{DC}}
\newcommand{\SPANGame}{\ensuremath{\mathit{SpanMPG}}}
\newcommand{\GCGGame}{\ensuremath{\mathit{SatCG}}}
\newcommand{\SimpleConnectedReachable}{\ensuremath{\mathit{SCR}}}

\newcommand{\Val}{\ensuremath{\mathit{Val}}}
\newcommand{\ValP}{\ensuremath{\mathit{Val}}}
\newcommand{\ValO}{\ensuremath{\mathit{Val}^{\mathit{best}}}}
\newcommand{\FM}{\mathcal{FM}}
\newcommand{\FiniteOne}{\mathcal{FM}_1}
\newcommand{\FiniteTwo}{\mathcal{FM}_2}
\newcommand{\Strategies}{\mathcal{S}}
\newcommand{\StrategiesOne}{\Strategies_1}
\newcommand{\StrategiesTwo}{\Strategies_2}
\newcommand{\ValueRegion}{\mathit{VR}}

\newcommand{\MinThresh}{\mathit{MT}}
\newcommand{\RelaxedMinThresh}{\mathit{RMT}}
\newcommand{\Rinf}{\R\cup\{-\infty,+\infty\}}
\newcommand{\Obj}{\mathit{obj}}

\newcommand{\VectorSetV}{\mathcal{V}}

\newcommand{\Simplex}{\mathcal{S}}
\newcommand{\IntSimplex}{\mathcal{SI}}
\newcommand{\RealSimplex}{\mathcal{RSI}}
\newcommand{\RatSimplex}{\mathcal{QSI}}
\newcommand{\WinOne}{\ensuremath{\mathit{Win}_1}}

\newcommand{\MaxFreeConst}{\operatorname{MFC}}

%matanf newcommands 

\newcommand{\MyComment}[1]{{\textbf{\color{blue} [Matan: #1]}}}

\begin{document}
%\input{tl}

\pagestyle{plain}
 


\newcommand{\AppendixContent}[1]{}


\title{DAO stack}

\author{Matan Field, Yaron Velner, others}
\institute{}

\maketitle

\begin{abstract}
DAO stack is a framework for...
\end{abstract}
\section{Introduction}
\section{System of Value}
\noindent \textbf{Agents.} An \emph{agent} is an entity with an address that can interact with blockchain contracts. Formally, an agent is either an account whose private key is known to some individual or a contract.
\newcommand{\Agents}{\mathcal{A}}
We denote the set of all agents by $\Agents$.
An \emph{agent operation} is a valid transaction (technically for Ethereum either an external or internal transaction).
\newcommand{\AgentOperations}{\mathcal{O}}
We denote the set of finite sequences of agent operations by $\AgentOperations$.
Let $f$ be a function from $\mathcal{O}$ to some domain $D$.
We say that a sequence $O'\in \mathcal{O}$ is the \emph{$f$-successor} of $O\in \mathcal{O}$, if $O'$ is the shortest extension of $O$ such that $f(O)\neq f(O')$ (if two shortest extensions exist, then one is chosen arbitrarily, e.g., according to lexicographical order).

\noindent \textbf{System of value.}
\newcommand{\SysValue}{\mathcal{S}}
A system of value is a tuple $\SysValue = \langle T, T_u, R, R_u, C, C_u, E_s, E_o, E_u, D, D_u, U \rangle$, where
intuitively
\begin{itemize}
\item $T$ is the \emph{native token} (or value) of the system and $T_u$ is a mechanism to update the token distribution.
\item $R$ is a \emph{reputation} metric, controlled by the system and $R_u$ is a mechanism to update the reputation distribution.
\item $C$ is a mechanism to submit \emph{contributions} for the system and $C_u$ is a mechanism to change $C$.
\item $E_s$ and $E_o$ are mechanisms for the evaluation of a contribution. The role of $E_s$ is to evaluate \emph{subjective} contributions and the role of $E_o$ is to evaluate \emph{objective} ones. $E_u$ is a mechanism to update $E_s$ and $E_o$.
\item $D$ is a delegation mechanism to perform agent actions in other systems and $D_u$ is a mechanism to change $D$.
\item $U$ is a mechanism to update all the \emph{update mechanisms}, namely, $T_u, R_u, C_u, E_u$ and $U$ itself.
\end{itemize}
\textbf{A system of value is an agent}.


We now formally define each of the components.

\noindent \textbf{Tokens.}
A token distribution is a function $T:\Agents\to \nat$ (where $\nat$ is the set of non-negative integers).
The distribution of the tokens, defined by $T$, can be changed by the mechanism $T_u$ in two ways, namely, \emph{transferring tokens} and \emph{minting tokens}.


\emph{Token transfer} changes the value of $T$ for at most two agents~\footnote{Technically, transfer between more parties are braked down into a sequence of two party transfers.}.
In a transfer the sum of all tokens in the system is not changed.
Formally, let $T$ be the token distribution before a transfer and $T'$ be the result of one transfer, then it always hold that $\sum_{a\in\Agents} T(a) = \sum_{a\in\Agents} T'(a)$.

\emph{Token minting} changes only the value of $T(\SysValue)$. It may increase or decrease it. \MyComment{I'm not sure decreasing make sense —since one can transfer his tokens to somewhere else, unless it's about frozen or constraint tokens - Yaron: you mentioned burning tokens. For example burning 5 tokens in exchange to one ether}

The update function $T_u$ dictates the rules on how $T$ is changed.
For example it can limit token transfer volume or prevent the transfer of tokens before some maturity threshold is reached.
It can also dictate minting policy such as constant inflation (or deflation) rate, backing of the token with other tokens, etc.


Formally, the update function $T_u$ is a function $T_u:\AgentOperations \to (\Agents \to \nat)$ (i.e., it assigns a distribution function to every sequence of operations), that satisfy the next restriction:
If a sequence of agent operations $O'$ is the $T_u$-successor of $O$, then either:
\begin{itemize}
\item $\sum_{a\in\Agents} (T_u(O))(a) = \sum_{a\in\Agents} (T_u(O'))(a)$ and
there exists exactly two agents $a_1,a_2$ such that $(T_u(O))(a_i) \neq (T_u(O'))(a_i)$ for $i=1,2$.
\item For every agent $a\neq \SysValue$: $(T_u(O))(a) = (T_u(O'))(a)$.
\end{itemize}
\MyComment{I didn't understand the "next restriction"; also, maybe there's a typo in there?}

\noindent \textbf{Reputation.}
A reputation is a function $R:\Agents \to \nat$ (maybe also negative reputation is allowed?).
\MyComment{Negative reputation has only meaning when entity are not disposable (which they usually are). Basically it means that entities are also tied up to some external data, a social-media profile, a physical identity, a company, external (physical or digital) ownership of assets etc.}
The reputation update mechanism may increase or decrease the reputation of a single agent. Therefor, reputation is not explicitly transferable~\footnote{An agent may chose to delegate its reputation by handing partial control over the agent's operations. \MyComment{This may have consequences}}.
Hence, the reputation update mechanism is a function $R_u : \Agents \to (\Agents\to \nat)$, such that if $O'$ is the $R_u$-successor of $O$, then there exists at most one agent $a$ with $(R_u(O))(a)\neq(R_u(O'))(a)$.  

If the system wishes to update the reputation of more than one agent, then it has to break it down to a sequence of single reputation updates. \MyComment{Why? not clearly possible; definitely not for BF-like reputation flow. Yaron: in any case, in solidity you can only do bounded number of operations. It is not possible to update the reputation of all members. In reputation flow, each agent would have to initiate the update of its own reputation.}


\noindent \textbf{Contribution submission.}
A contribution is a bulk of data that is submitted to the system by one of the agents.
A contribution can be immediately rejected (e.g., only agents from certain list are eligible to submit contribution) or can be stored in the contract for evaluation.
For the sake of abstraction we consider data bulks to be integers (e.g, the according to their byte encoding).
A contribution submission mechanism is a function $C: \nat \times \Agents \to \{0,1,2\}$.
Let $d$ be a contribution that is submitted by agent $a$.
Then:
\begin{itemize}
\item If $C(d,a) = 0$, then the contribution is not stored and immediately rejected.
\item If $C(d,a) = 1$, then the contribution is a candidate for \emph{objective evaluation}.
\item If $C(d,a) = 2$, then the contribution is a candidate for \emph{subjective evaluation}.
\end{itemize}
The update mechanism of $C$ is a function $C_u: \AgentOperations \to (\nat \times \Agents\to \{0,1,2\})$.
There are no restrictions on $C_u$.

\noindent \textbf{Evaluation of contributions.}
Contributors are rewarded (might also be penalized???) with a multi-value reward, which consists of:
(i)~reputation; (ii)~native (system) token; and (iii)~non-native tokens that the system control.
For simplicity we describe the case where the system holds at most one non-native token, namely the token of a system $\SysValue '$, and the extension to multiple non-native tokens is straight forward.
We say that an agent $a$ is rewarded by $(x,y,z)$ if its reputation $R(a)$ is increased by $x$, its native token balance $T(a)$ is increased by $y$ and its token balance in $\SysValue '$ is increased by $z$ via a transfer update.
Hence, a reward is a triplet in $\nat\times\nat\times\nat$ ($\nat ^ 3$).

The \emph{objective evaluation function} $E_o$ decides how to reward a contribution by considering only the identity of the submitter and the content of the submission.
I.e., the objective evaluation is a function $E_o : \nat \times \Agents \to \nat^3$.
For example, $E_o$ may reward $(0,1,0)$ for an agent who submitted a proof of paying 1 Ether to the system's contract.
Another example is where $E_o$ rewards $(0,0,1)$ for an agent who submitted a proof of transferring the native token back to the system.
A contribution $d$ from agent $a$ is eligible for a reward only if $C(d,a)=1$.

The \emph{subjective evaluation function} $E_s$ decides how to reward a contribution based on the actions of agents.
E.g., agents may evaluate the contribution by taking a vote.
Hence, the subjective evaluation mechanism is a function 
$E_o : \AgentOperations \times \nat \times \Agents \to \nat^3$
A contribution $d$ from agent $a$ is eligible for a reward only if $C(d,a)=2$.

TODO - should put restrictions on subjective evaluation? E.g., only reputation counts? Must be blind to the actual identity of the agent, etc.

\MyComment{Can unify objective and subjective distributions; can say generally agents vote on "proposals" which are forms of suggested distributions, e.g. 1. propose to distribute 100 tokens to this agent for this contribution; 2. propose to distribute x tokens to objective activity of this type; 3. propose to distribute tokens for subjective contributions according to median (or other rule); 4. propose to distribute tokens for subjective contributions according to ... mixture of objective measures and agents inputs of various degrees...}

The function $E_u$ updates the evaluation mechanisms.
Formally it is a function $E_u : \AgentOperations \to ((\nat \times \Agents \to \nat^3)\times(\AgentOperations \times \nat \times \Agents \to \nat^3))$.


\noindent \textbf{Inter-system extension}
For a system of value to be an agent in a different system of value, it must have the ability to perform agent operations.
In particular it should be able to submit contributions and to evaluate other contributions.
In the most general setting, the system should be able to delegate its token holdings and reputation\textbf{s} (i.e., reputation in other systems) to perform actions in other systems.
Formally, a \emph{delegation mechanism} is a function $D:\AgentOperations\to \AgentOperations$, which decides on $\SysValue$ next action or actions based the actions of its agents.
For example, agents can take a vote on the next action of the system.
We note that $D$ can only decide on actions that $\SysValue$ does in other systems.
The function $D_u$ updates the delegation mechanism.
Formally it is a function $D_u : \AgentOperations\to (\AgentOperations \to \AgentOperations)$.

\noindent \textbf{General update mechanism.}
Each of the token, reputation, contribution submission and contribution evaluation update mechanism and even the general update mechanism may be changed.
For this purpose we extend the evaluation mechanism, such that in addition to suggested reward, it would also output \emph{opinions} on whether the submitted contribution should replace $T_u, R_u, C_u, E_u, D_u$ or $U$.
The general update mechanism $U$ is a threshold for every mechanism, such that certain mechanism is replaced if and only if the alternative is evaluated with an higher value.



\section{Recommended Mechanisms}
\subsection{Recommended Token Mechanism}
\subsection{Recommended Reputation Mechanism}
\subsection{Recommended Contribution Mechanism}
\subsection{Recommended Upgrading Mechanism}
\section{Analyzing Circle of Systems}
\section{Implementation}

\bibliographystyle{plain}	% (uses file "plain.bst")
\bibliography{AGbibtex}

\end{document}
